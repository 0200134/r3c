#include "transpiler.hpp"
#include <iostream>
#include <fstream>
#include <cstdlib>

namespace fs = std::filesystem;
using namespace std;

namespace r3c {

Transpiler::Transpiler(const std::string& lts_version, bool verbose)
    : lts_version_(lts_version), verbose_(verbose) {}

// ==============================
// 🧱 Stage 1: C++ → Rust
// ==============================
bool Transpiler::cpp_to_rust(const fs::path& input, const fs::path& output_dir) {
    log("[Stage 1] Translating C++ → Rust: " + input.string());
    fs::create_directories(output_dir);

    // 실제로는 파서 + AST 기반 변환 로직이 들어감
    fs::path rust_file = output_dir / (input.stem().string() + ".rs");

    ofstream ofs(rust_file);
    if (!ofs.is_open()) return false;

    ofs << "// [auto-generated by r3c]\n";
    ofs << "// C++ → Rust Transpiled stub\n\n";
    ofs << "fn main() {\n";
    ofs << "    println!(\"Hello from transpiled Rust file!\");\n";
    ofs << "}\n";
    ofs.close();

    log("Generated: " + rust_file.string());
    return true;
}

// ==============================
// ⚙️ Stage 2: Rust → ASM
// ==============================
bool Transpiler::rust_to_asm(const fs::path& input, const fs::path& asm_out) {
    log("[Stage 2] Compiling Rust → ASM: " + input.string());

    std::string cmd = "rustc --emit asm -o \"" + asm_out.string() + "\" \"" + input.string() + "\"";
    int result = std::system(cmd.c_str());
    if (result != 0) {
        cerr << "❌ Rust → ASM transpilation failed.\n";
        return false;
    }

    log("Generated ASM: " + asm_out.string());
    return true;
}

// ==============================
// 🧩 Full pipeline
// ==============================
bool Transpiler::run_full_pipeline(const vector<string>& files,
                                   bool self_recompile,
                                   bool emit_asm,
                                   const string& asm_out,
                                   bool skip_bootstrap) {
    log("🚀 Starting full pipeline...");

    if (!check_environment()) {
        cerr << "❌ Environment check failed.\n";
        return false;
    }

    if (!skip_bootstrap && !perform_bootstrap()) {
        cerr << "❌ Bootstrap step failed.\n";
        return false;
    }

    for (const auto& file : files) {
        fs::path input(file);
        fs::path out_dir = "build/rust";

        if (!cpp_to_rust(input, out_dir))
            return false;

        if (emit_asm) {
            fs::path rust_src = out_dir / (input.stem().string() + ".rs");
            fs::path asm_file = asm_out.empty() ? fs::path("build/out.asm") : fs::path(asm_out);
            if (!rust_to_asm(rust_src, asm_file))
                return false;
        }
    }

    if (self_recompile)
        log("♻️  Self recompilation triggered (placeholder).");

    log("✅ Full pipeline completed successfully.");
    return true;
}

// ==============================
// 🔍 Helper functions
// ==============================
bool Transpiler::check_environment() {
    log("🔍 Checking compiler environment...");
    return true; // 실제 환경 감지 코드 필요
}

bool Transpiler::perform_bootstrap() {
    log("🧰 Performing bootstrap sequence...");
    return true; // 실제 부트스트랩 로직 필요
}

void Transpiler::log(const string& msg) {
    if (verbose_) cout << msg << endl;
}

} // namespace r3c
