// Auto-generated by r3c transpiler
// Rust LTS 1.65 compatible

namespace fs = std::filesystem;
bool transpile_to_rust(const vector<string>& files, const string& output_path);
fn main() {
    cout << "[r3c] Rust LTS Transpiler & Bootstrap\n";
    vector<string> args(argv + 1, argv + argc);
    // 1️⃣ self-bootstrap 모드
    if (!args.empty() && args[0] == "--bootstrap") {
        cout << "[BOOT] Starting self-bootstrap (C++ → Rust)...\n";
        // 변환할 C++ 소스 전체 목록
        vector<string> inputs = {
            "src/main.cpp",
            "src/stdlib.cpp",
            "src/transpiler.cpp"
        };
        fs::create_directories("rustlib");
        string out_rs = "rustlib/r3c_bootstrap.rs";
        if (!transpile_to_rust(inputs, out_rs)) {
            cerr << "[ERR] bootstrap transpilation failed.\n";
            return 1;
        }
        cout << "[BOOT] Generated: " << out_rs << endl;
        // Rust로 재컴파일
        string cmd = "rustc +1.65.0 \"" + out_rs + "\" -C opt-level=3 -o r3c_lts.exe";
        cout << "[BOOT CMD] " << cmd << endl;
        system(cmd.c_str());
        // 새로 빌드된 LTS 버전 실행
        cout << "[BOOT] Running r3c_lts.exe ...\n";
        system(".\\r3c_lts.exe --version");
        cout << "[BOOT] Completed successfully.\n";
    }
    // 2️⃣ 일반 Transpile 모드
    if (!args.empty() && args[0] == "--transpile-all") {
        cout << "[TRANSPILE] mode: multi-file\n";
        vector<string> inputs(args.begin() + 1, args.end());
        if (inputs.empty()) {
            cerr << "[ERR] no source files provided.\n";
            return 1;
        }
        fs::create_directories("rustlib");
        if (!transpile_to_rust(inputs, "rustlib/r3clib.rs")) {
            cerr << "[ERR] transpilation failed.\n";
            return 1;
        }
        cout << "[INFO] Compiling with Rust LTS 1.65...\n";
        system("rustc +1.65.0 rustlib/r3clib.rs -C opt-level=3 -o out_lts.exe");
        cout << "[RUN] Executing out_lts.exe...\n";
        system(".\\out_lts.exe");
        cout << "[DONE]\n";
    }
    // 기본 메시지
    cout << "Usage:\n";
    cout << "  r3c.exe --transpile-all <cpp files...>\n";
    cout << "  r3c.exe --bootstrap\n";
}
namespace r3c {
std::string injectStdLib() {
    std::string code;
    code += "%macro r3_print 1\n";
    code += "    lea rcx, [%1]\n";
    code += "    call puts\n";
    code += "%endmacro\n\n";
    code += "%macro r3_exit 1\n";
    code += "    mov rcx, %1\n";
    code += "    call ExitProcess\n";
    code += "%endmacro\n";
    return code;
}
}
namespace fs = std::filesystem;
static string transform_line(string line) {
    // 주석 제거
    if (line.find("//") == 0)
        return "";
    // 전처리문 제거
        return "";
    // main 함수 변환
    static regex main_fn_re(R"delim(\bint\s+main\s*\([^)]*\)\s*\{)delim");
    if (regex_search(line, main_fn_re)) {
        return "fn main() {";
    }
    // cout → println!
    static regex cout_re(R"delim(\s*std::cout\s*<<\s*"([^"]*)"\s*;)delim");
    smatch m;
    if (regex_match(line, m, cout_re)) {
        return "println!(\"" + m[1].str() + "\");";
    }
    // return 0 제거
    static regex ret_re(R"(\breturn\s+0\s*;)");
    if (regex_search(line, ret_re))
        return "";
    return line;
}
bool transpile_to_rust(const vector<string>& files, const string& output_path) {
    ofstream out(output_path);
    if (!out.is_open()) {
        cerr << "[ERR] cannot open " << output_path << endl;
        return false;
    }
    out << "// Auto-generated by r3c transpiler\n";
    out << "// Rust LTS 1.65 compatible\n\n";
    for (const auto& path : files) {
        ifstream in(path);
        if (!in.is_open()) {
            cerr << "[WARN] cannot open " << path << endl;
            continue;
        }
        string line;
        while (getline(in, line)) {
            string t = transform_line(line);
            if (!t.empty())
                out << t << "\n";
        }
        in.close();
    }
    out.close();
    cout << "[r3c-transpiler] Generated Rust source: " << output_path << endl;
    return true;
}
